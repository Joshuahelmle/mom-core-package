"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoTime = void 0;
const gotime_operator_1 = require("./enums/gotime_operator");
const gotime_parts_1 = require("./enums/gotime_parts");
const dayofmonth_limit_1 = require("./limits/dayofmonth_limit");
const dayofweek_limit_1 = require("./limits/dayofweek_limit");
const dayofyear_limit_1 = require("./limits/dayofyear_limit");
const month_limit_1 = require("./limits/month_limit");
const weekofmonth_limit_1 = require("./limits/weekofmonth_limit");
const weekofyear_limit_1 = require("./limits/weekofyear_limit");
const year_limit_1 = require("./limits/year_limit");
const time_limit_1 = require("./limits/time_limit");
const datetime_limit_1 = require("./limits/datetime_limit");
const gotime_unts_1 = require("./enums/gotime_unts");
class GoTime {
    constructor(definition) {
        this.limits = {};
        this.parse((this.definition = definition));
        this._unit = this.computeUnit();
    }
    test(date) {
        if (!date)
            return false;
        let result = false;
        for (const key in this.limits) {
            const limits = this.limits[key];
            if (limits) {
                var test = false;
                for (const limit of limits) {
                    if (limit.test(date)) {
                        test = true;
                        break;
                    }
                }
                if (!test) {
                    result = false;
                    break;
                }
                result = true;
            }
        }
        return result;
    }
    get unit() {
        return this._unit;
    }
    toString() {
        return this.definition;
    }
    computeUnit() {
        let unitIndex = gotime_unts_1.GoTimeUnits.length - 1;
        for (var key in this.limits) {
            const part = key;
            const limits = this.limits[part];
            if (limits) {
                for (var limit of limits) {
                    const index = gotime_unts_1.GoTimeUnits.indexOf(limit.unit);
                    if (index < unitIndex)
                        unitIndex = index;
                }
            }
        }
        const unit = gotime_unts_1.GoTimeUnits[unitIndex];
        return unit;
    }
    /**
     * Returns the next time this Go-Time will be active, or null if no active time is found.  The search is a brute force minute by minute check, so don't pass in large time spans
     * @param {Date} from Optional date to start checking from, or now in UTC
     * @param {Date} to Optional date to give up the search, or a week from now
     * @param {GoTimeUnit} unit Optional unit to step by through time.  Will default to largest step viable based on definition.  Also see `step`
     * @param {number} step Optional step or stride to sample the from-to range.  Make sure this won't skip over a potential active time based on your Go-Time definition.
     */
    next(from, to, unit = null, step = 1) {
        if (!unit) {
            unit = this._unit;
        }
        let ts;
        if (from) {
            ts = from.getTime();
        }
        else {
            // If there's no from time supplied, use "now" in UTC
            const d = new Date();
            const z = d.getTimezoneOffset();
            ts = d.getTime() + z * 60 * 1000;
        }
        let d = new Date(ts);
        // Go-Time doesn't go down to second granularity, so zero out seconds and milliseconds
        d.setSeconds(0);
        d.setMilliseconds(0);
        // Depending on the units, we have different functions for moving through time
        // Things like leapyear and days in a month are considered for
        const stepFunctions = {
            m: (v) => (d = new Date((ts += v * 1000 * 60))),
            h: (v) => (d = new Date((ts += v * 1000 * 60 * 60))),
            d: (v) => {
                d.setDate(d.getDate() + v);
                ts = d.getTime();
            },
            w: (v) => {
                d.setDate(d.getDate() + v * 7);
                ts = d.getTime();
            },
            M: (v) => {
                const o = d.getDate();
                d.setMonth(d.getMonth() + v);
                if (d.getDate() != o)
                    d.setDate(0);
                ts = d.getTime();
            },
            y: (v) => {
                const o = d.getDate();
                d.setFullYear(d.getFullYear() + v);
                if (d.getDate() != o)
                    d.setDate(0);
                ts = d.getTime();
            },
        };
        // Table of next smaller units
        let unitIndex = gotime_unts_1.GoTimeUnits.indexOf(unit);
        // Step forward in time, until we find a time that is active (tests true)
        let stepFn = stepFunctions[unit];
        const end = to ? to.getTime() : new Date(ts).setDate(new Date(ts).getDate() + 10);
        const start = ts;
        while (ts < end) {
            if (this.test(d))
                break;
            stepFn(step);
        }
        // If we found an active datetime...
        if (ts < end || unit != gotime_unts_1.GoTimeUnit.minute) {
            // If we were stepping in units greater than one minute, we
            //  need start stepping back in successively smaller units
            //  until we get to the first minute that tests true
            let smallerUnits = unitIndex >= 0 ? gotime_unts_1.GoTimeUnits[--unitIndex] : null;
            stepFn = smallerUnits ? stepFunctions[smallerUnits] : stepFn;
            while (smallerUnits) {
                stepFn(-1);
                if (ts < start || !this.test(d)) {
                    stepFn(1);
                    smallerUnits = unitIndex >= 0 ? gotime_unts_1.GoTimeUnits[--unitIndex] : null;
                    stepFn = smallerUnits ? stepFunctions[smallerUnits] : stepFn;
                }
            }
        }
        // Return null if we didn't find an active time
        return ts >= end ? null : d;
    }
    parse(definition) {
        var _a;
        definition = definition.toLowerCase();
        const matches = [...definition.matchAll(GoTime.defParse)];
        if (!(matches === null || matches === void 0 ? void 0 : matches.length)) {
            throw new Error(`Unable to parse GoTime definition.`);
        }
        for (const match of matches) {
            if (match.length !== 4) {
                throw new Error(`Unable to parse GoTime definition segment "${match[0]}".`);
            }
            const part = this.parsePart(match[1]);
            const op = this.parseOperator(match[2]);
            const value = match[3];
            let limit = null;
            switch (part) {
                case gotime_parts_1.GoTimePart.year:
                    limit = new year_limit_1.YearLimit(op, value);
                    break;
                case gotime_parts_1.GoTimePart.month:
                    limit = new month_limit_1.MonthLimit(op, value);
                    break;
                case gotime_parts_1.GoTimePart.weekOfYear:
                    limit = new weekofyear_limit_1.WeekOfYearLimit(op, value);
                    break;
                case gotime_parts_1.GoTimePart.weekOfMonth:
                    limit = new weekofmonth_limit_1.WeekOfMonthLimit(op, value);
                    break;
                case gotime_parts_1.GoTimePart.dayOfYear:
                    limit = new dayofyear_limit_1.DayOfYearLimit(op, value);
                    break;
                case gotime_parts_1.GoTimePart.dayOfMonth:
                    limit = new dayofmonth_limit_1.DayOfMonthLimit(op, value);
                    break;
                case gotime_parts_1.GoTimePart.dayOfWeek:
                    limit = new dayofweek_limit_1.DayOfWeekLimit(op, value);
                    break;
                case gotime_parts_1.GoTimePart.time:
                    limit = new time_limit_1.TimeLimit(op, value);
                    break;
                case gotime_parts_1.GoTimePart.datetime:
                    limit = new datetime_limit_1.DatetimeLimit(op, value);
                    break;
            }
            if (limit) {
                if (this.limits[part] === undefined) {
                    this.limits[part] = new Array();
                }
                (_a = this.limits[part]) === null || _a === void 0 ? void 0 : _a.push(limit);
            }
        }
    }
    parsePart(part) {
        if (!gotime_parts_1.GoTimeParts.includes(part)) {
            throw new Error(`Unknown GoTime part "${part}".`);
        }
        return part;
    }
    parseOperator(op) {
        if (!gotime_operator_1.GoTimeOperators.includes(op)) {
            throw new Error(`Unknown GoTime operator "${op}".`);
        }
        return op;
    }
}
exports.GoTime = GoTime;
GoTime.defParse = new RegExp(`\\s*(${gotime_parts_1.GoTimeParts.join('|')})\\s*(${gotime_operator_1.GoTimeOperators.join('|')})\\s*([^;\\r\\n]+)[;\\r\\n\\s]*`, 'gmi');
