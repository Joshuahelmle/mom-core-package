"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatetimeLimit = void 0;
const gotime_parts_1 = require("../enums/gotime_parts");
const gotime_unts_1 = require("../enums/gotime_unts");
const gotime_span_1 = require("../gotime_span");
const _limit_1 = require("./_limit");
class DatetimeLimit extends _limit_1.GoTimeLimit {
    constructor() {
        super(...arguments);
        this.part = gotime_parts_1.GoTimePart.datetime;
    }
    getCurrentValue(date) {
        return date.getTime();
    }
    parseValue(value) {
        const result = new Array();
        const values = value.split(',').map((v) => v.trim());
        for (var val of values) {
            const [start, end] = val.split('|').map((v) => this.toNumber(v.trim()));
            if (start === undefined) {
                throw new Error(`Unable to parse value "${val}"`);
            }
            result.push(new gotime_span_1.GoTimeSpan(start, end));
        }
        return result;
    }
    computeUnit() {
        let unitIndex = gotime_unts_1.GoTimeUnits.length - 1;
        for (const span of this.values) {
            let i = unitIndex;
            if (span.end !== undefined) {
                const diffMinutes = (span.end - span.value) / (60 * 1000);
                if (diffMinutes < 365 * 24 * 60) {
                    if (diffMinutes < 31 * 24 * 60) {
                        if (diffMinutes < 24 * 60) {
                            if (diffMinutes < 60) {
                                if (diffMinutes <= 0)
                                    throw new Error(`Start and End datetime may not be the same.`);
                                else
                                    i = gotime_unts_1.GoTimeUnits.indexOf(gotime_unts_1.GoTimeUnit.minute);
                            }
                            else
                                i = gotime_unts_1.GoTimeUnits.indexOf(gotime_unts_1.GoTimeUnit.hour);
                        }
                        else
                            i = gotime_unts_1.GoTimeUnits.indexOf(gotime_unts_1.GoTimeUnit.day);
                    }
                    else
                        i = gotime_unts_1.GoTimeUnits.indexOf(gotime_unts_1.GoTimeUnit.month);
                }
                else
                    i = gotime_unts_1.GoTimeUnits.indexOf(gotime_unts_1.GoTimeUnit.year);
            }
            else
                i = gotime_unts_1.GoTimeUnits.indexOf(gotime_unts_1.GoTimeUnit.year);
            if (i < unitIndex)
                unitIndex = i;
        }
        return gotime_unts_1.GoTimeUnits[unitIndex];
    }
    toNumber(n) {
        const result = Date.parse(n);
        if (isNaN(result))
            throw new Error(`Invalid datetime ${n}`);
        const date = new Date(result);
        if (date.getMilliseconds() !== 0)
            throw new Error(`Invalid datetime ${n}.  Can't contain milliseconds.`);
        if (date.getSeconds() !== 0)
            throw new Error(`Invalid datetime ${n}.  Can't contain seconds.`);
        return result;
    }
}
exports.DatetimeLimit = DatetimeLimit;
function findUnit(date) {
    if (date.getMinutes() == 0) {
        if (date.getHours() == 0) {
            if (date.getDate() == 1) {
                if (date.getMonth() == 0) {
                    return gotime_unts_1.GoTimeUnit.year;
                }
                return gotime_unts_1.GoTimeUnit.month;
            }
            return gotime_unts_1.GoTimeUnit.day;
        }
        return gotime_unts_1.GoTimeUnit.hour;
    }
    return gotime_unts_1.GoTimeUnit.minute;
}
