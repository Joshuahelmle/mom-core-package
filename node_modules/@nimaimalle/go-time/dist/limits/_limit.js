"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.goTimeToNumber = exports.GoTimeLimit = void 0;
const gotime_operator_1 = require("../enums/gotime_operator");
const gotime_span_1 = require("../gotime_span");
class GoTimeLimit {
    constructor(op, value) {
        this.operator = op;
        this.values = this.parseValue(value);
        this.unit = this.computeUnit();
    }
    parseValue(value) {
        const result = new Array();
        const values = value.split(',').map((v) => v.trim());
        for (var val of values) {
            const [start, end] = val.split(/[-|]/).map((v) => this.toNumber(v.trim()));
            if (start === undefined) {
                throw new Error(`Unable to parse value "${val}"`);
            }
            result.push(new gotime_span_1.GoTimeSpan(start, end));
        }
        return result;
    }
    toNumber(n) {
        if (!n)
            return Number.NaN;
        const v = parseFloat(n);
        if (!isNaN(v) && isFinite(v))
            return v;
        return Number.NaN;
    }
    test(date) {
        let result = false;
        const value = this.getCurrentValue(date);
        for (const span of this.values) {
            if (this.operator != gotime_operator_1.GoTimeOperator.equals && span.end !== undefined) {
                if (span.end !== undefined)
                    throw new Error(`Operator ${this.operator} doesn't work with a value range.`);
            }
            switch (this.operator) {
                case gotime_operator_1.GoTimeOperator.equals:
                    result = span.includes(value);
                    break;
                case gotime_operator_1.GoTimeOperator.less:
                    result = value < span.value;
                    break;
                case gotime_operator_1.GoTimeOperator.lessEq:
                    result = value <= span.value;
                    break;
                case gotime_operator_1.GoTimeOperator.greater:
                    result = value > span.value;
                    break;
                case gotime_operator_1.GoTimeOperator.greaterEq:
                    result = value >= span.value;
                    break;
            }
            if (result)
                break;
        }
        return result;
    }
}
exports.GoTimeLimit = GoTimeLimit;
function goTimeToNumber(n) {
    if (!n)
        return undefined;
    const v = parseFloat(n);
    if (!isNaN(v) && isFinite(v))
        return v;
    return undefined;
}
exports.goTimeToNumber = goTimeToNumber;
