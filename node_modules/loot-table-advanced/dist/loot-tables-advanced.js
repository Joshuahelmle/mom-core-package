"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetLoot = exports.GetLootAsync = exports.LootTableSummary = exports.LootTableSummaryAsync = exports.CheckLootTableEntry = exports.LootTableEntry = exports.ParseLootID = exports.AddLoot = void 0;
function AddLoot(loot, item) {
    const i = loot.findIndex((e) => e.id == item.id);
    if (i >= 0)
        loot[i].quantity += item.quantity;
    else
        loot.push({ id: item.id, quantity: item.quantity });
    return loot;
}
exports.AddLoot = AddLoot;
function MergeLoot(a, b) {
    b.forEach((e) => AddLoot(a, e));
    return a;
}
function CloneEntry(entry) {
    return JSON.parse(JSON.stringify(entry));
}
function CloneLootTable(table) {
    const result = JSON.parse(JSON.stringify(table));
    return result;
}
function isPositiveInt(value) {
    return value >= 0 && value === Math.floor(value);
}
const rxLootTableEntryID = new RegExp("^@?([a-z0-9_-]+)(\\(([0-9]+)\\))?$", "i");
function ParseLootID(id) {
    let count = 0;
    let name = null;
    const matches = id.match(rxLootTableEntryID);
    if (matches) {
        name = matches[1];
        count = matches[3] === undefined ? 1 : parseInt(matches[3]);
    }
    return { id: name, count };
}
exports.ParseLootID = ParseLootID;
function LootTableEntry(id, weight = 1, min = 1, max = 1, step = 1, group = 1) {
    if (id !== null && !rxLootTableEntryID.test(id))
        throw Error(`LootTableEntry ${id} invalid id format.`);
    // if (!isPositiveInt(min) || !isPositiveInt(max))
    //   throw Error(
    //     `LootTableEntry ${id} min and max must both be non-negative integers.`
    //   )
    if (min > max)
        throw Error(`LootTableEntry ${id} min must be less than or equal to max.`);
    if ((!isPositiveInt(step) || step == 0) && !Number.isNaN(step))
        throw Error(`LootTableEntry ${id} step must be a positive integer or NaN.`);
    if (!isPositiveInt(group))
        throw Error(`LootTableEntry ${id} group must be a non-negative integer.`);
    if (!isPositiveInt(weight))
        throw Error(`LootTableEntry ${id} weight must be a non-negative integer.`);
    return { id, min, max, step, group, weight };
}
exports.LootTableEntry = LootTableEntry;
function CheckLootTableEntry(entry) {
    if (entry.id !== null && !rxLootTableEntryID.test(entry.id))
        throw Error(`LootTableEntry ${entry.id} invalid id format.`);
    if (typeof entry.min === "number" && typeof entry.max === "number" && entry.min > entry.max)
        throw Error(`LootTableEntry ${entry.id} min must be less than or equal to max.`);
    if (typeof entry.step === "number" && (!isPositiveInt(entry.step) || entry.step == 0) && !Number.isNaN(entry.step))
        throw Error(`LootTableEntry ${entry.id} step must be a positive integer or NaN.`);
    if (typeof entry.group === "number" && !isPositiveInt(entry.group))
        throw Error(`LootTableEntry ${entry.id} group must be a non-negative integer.`);
    if (typeof entry.weight === "number" && !isPositiveInt(entry.weight))
        throw Error(`LootTableEntry ${entry.id} weight must be a non-negative integer.`);
    return entry;
}
exports.CheckLootTableEntry = CheckLootTableEntry;
const loot_defaults = {
    id: null,
    weight: 1,
    min: 1,
    max: 1,
    step: 1,
    group: 1,
    transform: null,
};
function FillInLootEntryDefaults(entry) {
    if (entry.id === undefined)
        entry.id = null;
    if (entry.weight === undefined)
        entry.weight = loot_defaults.weight;
    if (entry.min === undefined)
        entry.min = loot_defaults.min;
    if (entry.max === undefined)
        entry.max = Math.max(loot_defaults.max, loot_defaults.min);
    if (entry.step === undefined)
        entry.step = loot_defaults.step;
    if (entry.group === undefined)
        entry.group = loot_defaults.group;
    return entry;
}
const MAX_NESTED = 100;
function LootTableSummaryAsync(table, resolver) {
    return __awaiter(this, void 0, void 0, function* () {
        return _LootTableSummaryAsync(table, resolver);
    });
}
exports.LootTableSummaryAsync = LootTableSummaryAsync;
function _LootTableSummaryAsync(table, resolver, depth = 0, multiple = 1, // Not supported yet
min = 1, max = 1) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (!Array.isArray(table))
            throw new Error("Not a loot table");
        if (depth > MAX_NESTED)
            throw new Error(`Too many nested loot tables`);
        let result = sum(condense(table));
        const length = result.length;
        for (let i = 0; i < length; i++) {
            const entry = FillInLootEntryDefaults(result[i]);
            const group = entry.group;
            delete entry.weight;
            delete entry.step;
            delete entry.group;
            let otherTable = entry._nested;
            let otherCount = 1;
            if ((_a = entry.id) === null || _a === void 0 ? void 0 : _a.startsWith("@")) {
                const otherInfo = ParseLootID(entry.id.substring(1));
                if (!otherInfo.id)
                    throw new Error(`Unable to parse ${entry.id}`);
                otherCount = otherInfo.count;
                if (!otherTable) {
                    if (!resolver)
                        throw new Error(`No resolver for ${otherInfo.id}`);
                    otherTable = yield resolver(otherInfo.id);
                    if (!otherTable)
                        throw new Error(`${otherInfo.id} could not be resolved`);
                }
            }
            if (otherTable) {
                const otherSummarized = yield _LootTableSummaryAsync(otherTable, resolver, depth + 1, otherCount, entry.min, entry.max);
                otherSummarized.map((e) => (e.group = group));
                result.push(...otherSummarized);
                result = condense(result);
                sum(result);
            }
        }
        result.map((e) => delete e.group);
        result = sum(result);
        const scaled = scale(result.filter((e) => { var _a; return typeof e.id === "string" && !((_a = e.id) === null || _a === void 0 ? void 0 : _a.startsWith("@")); }), min, max);
        return scaled;
    });
}
function LootTableSummary(table, resolver) {
    return _LootTableSummary(table, resolver);
}
exports.LootTableSummary = LootTableSummary;
function _LootTableSummary(table, resolver, depth = 0, multiple = 1, // Not supported yet
min = 1, max = 1) {
    var _a;
    if (!Array.isArray(table))
        throw new Error("Not a loot table");
    if (depth > MAX_NESTED)
        throw new Error(`Too many nested loot tables`);
    let result = sum(condense(table));
    const length = result.length;
    for (let i = 0; i < length; i++) {
        const entry = FillInLootEntryDefaults(result[i]);
        const group = entry.group;
        delete entry.weight;
        delete entry.step;
        delete entry.group;
        let otherTable = entry._nested;
        let otherCount = 1;
        if ((_a = entry.id) === null || _a === void 0 ? void 0 : _a.startsWith("@")) {
            const otherInfo = ParseLootID(entry.id.substring(1));
            if (!otherInfo.id)
                throw new Error(`Unable to parse ${entry.id}`);
            otherCount = otherInfo.count;
            if (!otherTable) {
                if (!resolver)
                    throw new Error(`No resolver for ${otherInfo.id}`);
                otherTable = resolver(otherInfo.id);
                if (!otherTable)
                    throw new Error(`${otherInfo.id} could not be resolved`);
            }
        }
        if (otherTable) {
            const otherSummarized = _LootTableSummary(otherTable, resolver, depth + 1, otherCount, entry.min, entry.max);
            otherSummarized.map((e) => (e.group = group));
            result.push(...otherSummarized);
            result = condense(result);
            sum(result);
        }
    }
    result.map((e) => delete e.group);
    result = sum(result);
    const scaled = scale(result.filter((e) => { var _a; return typeof e.id === "string" && !((_a = e.id) === null || _a === void 0 ? void 0 : _a.startsWith("@")); }), min, max);
    return scaled;
}
/**
 * Combine all entries with the same id and group, making min be the smallest min, and max be the largest max
 * @param input Loot Table
 * @returns
 */
function condense(input) {
    const result = new Array();
    for (const entry of input) {
        const existing = result.find((x) => x.id === entry.id && x.group === entry.group);
        if (existing) {
            existing.min = Math.min(existing.min, entry.min);
            existing.max = Math.max(existing.max, entry.max);
        }
        else {
            result.push(CloneEntry(entry));
        }
    }
    return result;
}
/**
 * Combine all entries with the same id, summing the mins and maxes
 * @param input Loot Table
 * @returns
 */
function sum(input, into) {
    const result = into !== null && into !== void 0 ? into : new Array();
    for (const entry of input) {
        const existing = result.find((x) => x.id === entry.id);
        if (existing) {
            existing.min += entry.min;
            existing.max += entry.max;
        }
        else {
            result.push(CloneEntry(entry));
        }
    }
    return result;
}
function scale(input, min, max) {
    for (const entry of input) {
        entry.min *= min;
        entry.max *= max;
    }
    return input;
}
function GetLootAsync(table, count = 1, resolver, depth = 0) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (!Array.isArray(table))
            throw new Error("Not a loot table");
        if (depth > MAX_NESTED)
            throw new Error(`Too many nested loot tables`);
        if (count != 1) {
            table = CloneLootTable(table);
        }
        const result = new Array();
        const groups = new Set();
        table.map((e) => groups.add(e.group));
        for (let pull = 0; pull < count; ++pull) {
            for (const groupID of groups) {
                const entries = table
                    .filter((e) => e.group === groupID)
                    .map(FillInLootEntryDefaults);
                const totalWeight = entries
                    .map((e) => e.weight)
                    .reduce((a, b) => a + b, 0);
                if (totalWeight == 0) {
                    continue;
                }
                const rand = Math.random() * totalWeight;
                let entry = null;
                let sum = 0;
                for (const e of entries) {
                    sum += e.weight;
                    if (sum > rand) {
                        entry = e;
                        break;
                    }
                }
                if (entry === null)
                    throw new Error(`No loot table row could be selected.`);
                const range = isNaN(entry.step)
                    ? entry.max - entry.min
                    : Math.floor((entry.max - entry.min + entry.step) / entry.step);
                const rnd = entry.transform
                    ? entry.transform(Math.random())
                    : Math.random();
                let quantity = entry.min +
                    (isNaN(entry.step) ? rnd * range : Math.floor(rnd * range) * entry.step);
                let absQuantity = Math.abs(quantity);
                if (absQuantity > 0) {
                    if (count != 1) {
                        absQuantity = Math.max(absQuantity, entry.weight);
                        quantity = quantity < 0 ? -absQuantity : absQuantity;
                        entry.weight -= absQuantity;
                    }
                    let otherTable = entry._nested;
                    let otherCount = 1;
                    if ((_a = entry.id) === null || _a === void 0 ? void 0 : _a.startsWith("@")) {
                        const otherInfo = ParseLootID(entry.id.substring(1));
                        otherCount = otherInfo.count;
                        if (!otherInfo.id)
                            throw new Error(`Unable to parse ${entry.id}`);
                        if (!otherTable) {
                            if (!resolver)
                                throw new Error(`No resolver for ${otherInfo.id}`);
                            otherTable = yield resolver(otherInfo.id);
                            if (!otherTable)
                                throw new Error(`${otherInfo.id} could not be resolved`);
                        }
                    }
                    if (otherTable) {
                        for (let i = 0; i < quantity; i++) {
                            const loot = yield GetLootAsync(otherTable, otherCount, resolver, ++depth);
                            depth--;
                            MergeLoot(result, loot);
                        }
                    }
                    else {
                        if (entry.id !== null) {
                            AddLoot(result, { id: entry.id, quantity });
                        }
                    }
                }
            }
        }
        return result;
    });
}
exports.GetLootAsync = GetLootAsync;
function GetLoot(table, count = 1, resolver, depth = 0) {
    var _a;
    if (!Array.isArray(table))
        throw new Error("Not a loot table");
    if (depth > MAX_NESTED)
        throw new Error(`Too many nested loot tables`);
    if (count != 1) {
        table = CloneLootTable(table);
    }
    const result = new Array();
    const groups = new Set();
    table.map((e) => groups.add(e.group));
    for (let pull = 0; pull < count; ++pull) {
        for (const groupID of groups) {
            const entries = table
                .filter((e) => e.group === groupID)
                .map(FillInLootEntryDefaults);
            const totalWeight = entries
                .map((e) => e.weight)
                .reduce((a, b) => a + b, 0);
            if (totalWeight == 0) {
                continue;
            }
            const rand = Math.random() * totalWeight;
            let entry = null;
            let sum = 0;
            for (const e of entries) {
                sum += e.weight;
                if (sum > rand) {
                    entry = e;
                    break;
                }
            }
            if (entry === null)
                throw new Error(`No loot table row could be selected.`);
            const range = isNaN(entry.step)
                ? entry.max - entry.min
                : Math.floor((entry.max - entry.min + entry.step) / entry.step);
            const rnd = entry.transform
                ? entry.transform(Math.random())
                : Math.random();
            let quantity = entry.min +
                (isNaN(entry.step) ? rnd * range : Math.floor(rnd * range) * entry.step);
            let absQuantity = Math.abs(quantity);
            if (absQuantity > 0) {
                if (count != 1) {
                    absQuantity = Math.max(absQuantity, entry.weight);
                    quantity = quantity < 0 ? -absQuantity : absQuantity;
                    entry.weight -= absQuantity;
                }
                let otherTable = entry._nested;
                let otherCount = 1;
                if ((_a = entry.id) === null || _a === void 0 ? void 0 : _a.startsWith("@")) {
                    const otherInfo = ParseLootID(entry.id.substring(1));
                    otherCount = otherInfo.count;
                    if (!otherInfo.id)
                        throw new Error(`Unable to parse ${entry.id}`);
                    if (!otherTable) {
                        if (!resolver)
                            throw new Error(`No resolver for ${otherInfo.id}`);
                        otherTable = resolver(otherInfo.id);
                        if (!otherTable)
                            throw new Error(`${otherInfo.id} could not be resolved`);
                    }
                }
                if (otherTable) {
                    for (let i = 0; i < quantity; i++) {
                        const loot = GetLoot(otherTable, otherCount, resolver, ++depth);
                        depth--;
                        MergeLoot(result, loot);
                    }
                }
                else {
                    if (entry.id !== null) {
                        AddLoot(result, { id: entry.id, quantity });
                    }
                }
            }
        }
    }
    return result;
}
exports.GetLoot = GetLoot;
